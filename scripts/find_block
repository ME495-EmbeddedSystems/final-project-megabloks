#!/usr/bin/env python
"""
Subscribes to gazebo service to get location of a block for testing
"""

import sys
import copy
import rospy
import numpy as np

# get block location
from gazebo_msgs.srv import GetModelState

# moveit
import moveit_commander
import moveit_msgs.msg
import geometry_msgs.msg
from std_msgs.msg import String
from moveit_commander.conversions import pose_to_list

import baxter_interface

class find_block(object):
    def __init__(self):
        # set up gazebo service to find block
        self.model_coords = rospy.ServiceProxy('/gazebo/get_model_state',GetModelState)

        # initialize moveit commander
        moveit_commander.roscpp_initialize(sys.argv)
        robot = moveit_commander.RobotCommander()
        scene = moveit_commander.PlanningSceneInterface()
        group_name = 'left_arm'
        group = moveit_commander.MoveGroupCommander(group_name)
        display_trajectory_publisher = rospy.Publisher('/move_group/display_planned_path',
                                               moveit_msgs.msg.DisplayTrajectory,
                                               queue_size=20)

        # print basic info for debugging
        # We can get the name of the reference frame for this robot:
        planning_frame = group.get_planning_frame()
        print "============ Reference frame: %s" % planning_frame

        # We can also print the name of the end-effector link for this group:
        eef_link = group.get_end_effector_link()
        print "============ End effector: %s" % eef_link

        # We can get a list of all the groups in the robot:
        group_names = robot.get_group_names()
        print "============ Robot Groups:", robot.get_group_names()

        # Sometimes for debugging it is useful to print the entire state of the
        # robot:
        print "============ Printing robot state"
        print robot.get_current_state()
        print ""

        # get goal from gazebo
        goal = self.get_location('block1')

        # plan motion to goal
        pose_goal = geometry_msgs.msg.Pose()
        pose_goal.orientation.w = 1.0
        pose_goal.position.x = goal[0]
        pose_goal.position.y = goal[1]
        pose_goal.position.z = goal[2]
        group.set_pose_target(pose_goal)

        # compute and execute plan
        plan = group.go(wait=True)
        # Calling `stop()` ensures that there is no residual movement
        group.stop()
        # It is always good to clear your targets after planning with poses.
        # Note: there is no equivalent function for clear_joint_value_targets()
        group.clear_pose_targets()
        rospy.spin()

    def get_location(self,model):
        self.object_coords = self.model_coords(model,'')
        x_pos = self.object_coords.pose.position.x
        y_pos = self.object_coords.pose.position.y
        z_pos = self.object_coords.pose.position.z
        return [x_pos, y_pos, z_pos]

if __name__ == '__main__':
    try: 
        rospy.init_node('find_block',anonymous=True)
        block_loc = find_block()
    except rospy.ROSInterruptException:
        pass
