#!/usr/bin/env python
"""
Set up configuration for hardware testing and moves arm to 'start' position

inspired by `ik_pick_and_place_demo.py` -- Baxter RSDK Inverse Kinematics Pick and Place Demo by Rethink Robotics
"""

import argparse
import struct
import sys
import copy

import rospy
import rospkg
import numpy as np
from tf.transformations import quaternion_from_euler as angle_trans

from geometry_msgs.msg import (
    PoseStamped,
    Pose,
    Point,
    Quaternion,
)
from std_msgs.msg import (
    Header,
    Empty,
)

from baxter_interface.camera import CameraController
import baxter_interface


class setup(object):
    def __init__(self, limb, verbose=True):
        self._limb_name = limb # string
        self._verbose = verbose # bool
        self._limb = baxter_interface.Limb(limb)
        self._gripper = baxter_interface.Gripper(limb)
        # verify robot is enabled
        print("Getting robot state... ")
        self._rs = baxter_interface.RobotEnable(baxter_interface.CHECK_VERSION)
        self._init_state = self._rs.state().enabled
        print("Enabling robot... ")
        # calibrate gripper
        self._gripper.calibrate(block=True)
        #self._rs.enable()

    def move_to_start(self, start_angles=None):
        print("Moving the {0} arm to start pose...".format(self._limb_name))
        if not start_angles:
            start_angles = dict(zip(self._joint_names, [0]*7))
        self._guarded_move_to_joint_position(start_angles)
        self.gripper_open()
        rospy.sleep(1.0)

    def _guarded_move_to_joint_position(self, joint_angles):
        if joint_angles:
            self._limb.move_to_joint_positions(joint_angles)
        else:
            rospy.logerr("No Joint Angles provided for move_to_joint_positions. Staying put.")

    def gripper_open(self):
        self._gripper.open()
        rospy.sleep(1.0)

    def gripper_close(self):
        self._gripper.close()
        rospy.sleep(1.0)


def open_cam(camera, res):

  if not any((res[0] == r[0] and res[1] == r[1]) for r in CameraController.MODES):
    rospy.logerr("Invalid resolution provided.")
    # Open camera
    cam = CameraController(camera) # Create camera object
    cam.resolution = res # Set resolution
    cam.open() # open
    # Close camera
def close_cam(camera):
  cam = CameraController(camera) # Create camera object
  cam.close() # close

def main():
    num_blocks = 3 # reducing number for testing

    rospy.init_node("test_hw")
    
    # wait for the All Clear from emulator startup
    #rospy.wait_for_message("/robot/sim/started", Empty)
    
    limb = 'left'
    # Starting Joint angles for left arm
    starting_joint_angles_left = {'left_w0': 0.67,
                                  'left_w1': 1.03,
                                  'left_w2': -0.5,
                                  'left_e0': -1.19,
                                  'left_e1': 1.94,
                                  'left_s0': -0.08,
                                  'left_s1': -1.}
    stp_left = setup(limb) 

    limb = 'right'
    # Starting Joint angles for right arm
    starting_joint_angles_right = {'right_w0': 2.74,  #0.85,
                                   'right_w1': -1.09,  #1.52,
                                   'right_w2': -2.71,   #0.05,
                                   'right_e0': 0.36,   #-0.99,
                                   'right_e1': 0.97,   #0.80,
                                   'right_s0': 0.95,   #1.46,
                                   'right_s1': -0.5}  #-0.46}
    
    stp_right = setup(limb)

    # Move to the desired starting angles
    stp_left.move_to_start(starting_joint_angles_left)
    stp_right.move_to_start(starting_joint_angles_right)
    close_cam('left_hand_camera')
    close_cam('right_hand_camera')
    close_cam('head_camera')
    open_cam('right_hand_camera',(1280,800))
    #rospy.spin()

if __name__ == '__main__':
    sys.exit(main())
